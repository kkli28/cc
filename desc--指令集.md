# 指令集

虚拟机的指令分为带参数（一个参数）和不带参数的。带参数的指令在前，便于打印调试信息。

需要注意的几条指令，首先是对MOV指令的分解：
```
1. IMM <num>  取立即数
2. LC         从ax所指的地址处取char值
3. LI         从ax所指的地址处取int值
4. SC         将ax中的char值存放到栈顶所指的地址处
5. SI         将ax中的int值存放到栈顶所指的地址处
这五条指令，实际是为了模拟x86中 MOV <dest>, <src> 指令的功能，完成取数，存数。
但是MOV指令功能太复杂，具有两个操作数，且操作数的类型不止一种，实际上还分为
MOVB/MOVW等，而本虚拟机支持的指令最多一个参数，且为了简单，所有指令的操作数必须类型单一，因此使用了5条指令来模拟MOV指令。
在存储char/int时，ax寄存器中存放的是该char/int值，栈顶则是变量的地址，使用
SC/SI完成对char/int数据的存储。
在取数时，ax寄存器中存放的是变量的地址，使用LC/LI可将变量的值取出，并存放于ax中。
立即数没有用隐含变量来存储，而是直接嵌入到指令中。
```

之后是对函数调用及返回的步骤分解：
```
1. CALL       跳转到*pc所指的地址，进行函数调用
2. ENT        创建调用帧，保存当前栈指针，并在栈上保留一定的空间，用以存放局部变量
3. ADJ        将函数参数从栈上清除。
4. LEV        结束函数调用
因为函数调用比较复杂，因此使用了4个指令进行分解。在进行函数调用前，参数就进栈，
然后由ENT创建调用帧，保存当前信息。之后由CALL执行直接的pc跳转，到达函数代码位置。
函数执行完后，由LEV结束函数调用，恢复之前的信息，但是此时函数参数依旧在栈上，
因此ADJ的任务就是将这些参数出栈，完成对之前信息的完全恢复。
最后LEV将之前的信息恢复，结束对函数的调用。

函数调用帧：
|    ...    | <-- 高地址
|    arg1   | <-- 第一个参数
|    arg2   |
|    arg3   |
|    ...    |
|  ret addr | <-- 返回地址
|  old bp   | <-- new bp (新bp指向之前的栈顶，而之前的栈顶存放的是旧bp)
|  local1   | <-- 局部变量
|  local2   |
|  local3   |
|    ...    |
```

下面是各条指令的介绍：

> 带参数的指令

```
>> LEA <num>

作用：将相对于bp寄存器的地址放入ax寄存器中。因为函数参数与局部变量都是相对于bp寄存器所指位置存放的，因此实际是完成对参数/变量的取地址操作。

用法： LEA 12，是将bp+12放入ax中，这样位于bp+12处的变量的地址就在ax中了。

>> IMM <num>

作用：取立即数，其参数 num 紧邻IMM，存放在代码段中IMM的下一个位置。
用法：IMM 12，将立即数12放入ax寄存器中。

>> JMP <num>

作用：无条件跳转到某个位置。
用法：JMP 0xff，将pc寄存器的值设置为0xff。

>> CALL <num>

作用：函数调用，类似 JMP <num> 的功能，但是它会将下一条指令 (pc+1) 存储。
用法：CALL 0xff，将 (pc+1) 存储，然后设置pc为0xff

>> JZ <num>

作用：当ax寄存器中的值为0时，进行跳转。
用法：JZ 0xff，当ax寄存器中的值为0时，跳转到（设置pc值为）0xff。

>> JNZ <num>

作用：当ax寄存器中的值为非0时，进行跳转。
用法：JNZ 0xff，当ax寄存器中的值为非0时，跳转到（设置pc值为）0xff。

>> ENT <num>

作用：新建函数调用帧，即保存bp，sp，(pc+1)等信息，然后栈上预留函数局部变量的位置。
用法：ENT 12，新建函数调用帧，然后在栈上预留12个字节的空间，用以存放局部变量。

//TODO: 局部变量何时进栈？

>> ADJ <num>

作用：将函数参数出栈。
用法：ADJ 12，将函数内共占12个字节的局部变量出栈。
```

> 不带参数的指令

```
>> LEV

作用：从函数调用中返回，从函数调用帧中恢复调用前的状态，即恢复bp，sp，pc的值。此时函数
参数依旧在栈上，还需要 ADJ <num> 将参数清除，完全结束函数调用。

>> LI

作用：从ax所指的内存中取出一个int。约定ax的值是一个int变量的地址。

>> LC

作用：从ax所指的内存中取出一个char。约定ax的值是一个char变量的地址。

>> SI

作用：将ax中的int值存入栈顶所指的内存中。约定栈顶的值是一个int变量的地址。

>> SC

作用：将ax中的char值存入栈顶所指的内存中。约定栈顶的值是一个char变量的地址。

>> PUSH

作用：将ax寄存器的值入栈。

>> OR / XOR / AND / EQ / NE / LT / GT / LE / GE / SHL / SHR / ADD / SUB / MUL / DIV / MOD

作用：二元运算符，将栈顶作为第一个操作数，将ax的值作为第二个操作数进行对应的运算，结果存放于ax中，且
栈顶元素在计算后清除。

>> PRTF

作用：系统内置函数，调用C语言的printf语句打印输出。

//TODO: 是如何获得参数数量，可最多支持6个参数？

>> MALC

作用：系统内置函数，调用C语言的malloc语句实现动态内存分配。

>> EXIT

作用：系统内置函数，调用C语言的exit语句退出程序。

//TODO: 尝试提供scanf等类似的函数，如get、put等。
```
