基于寄存器的虚拟机在编译器生成代码阶段需要考虑寄存器分配的问题，并且指令集也更加复杂，因此虚拟机的实现也更加复杂，而基于栈的虚拟机则省去了这些不必要的麻烦，因此虚拟机设计部分采用基于栈的虚拟机。

基于栈的虚拟机指令，通常都是无地址指令，指令的操作数都隐含在栈上。部分指令可设计为带有操作数，可减少指令数量，且不会增加实现复杂度。

本指令集有带一个参数的指令和不带参数的指令。带一个参数的指令，其参数放在当前指令存储位置的下一个位置中。

/**********
在设计指令集之前，需要设计指令的操作数约定。

算术运算都是将栈顶的一个数或两个数进行操作，然后存储在栈顶上，因此在执行操作前需要将操作数按照正确的顺序入栈。

变量存储于固定位置，且需要考虑变量作为左值和右值的情况。作为右值则可以直接取其值，如a=b+c中，变量b和c作为右值，使用时直接取值即可。但是作为左值时，需要将值写入变量中，如a，需要将b+c的值写入a中，此时应该获取的是a的地址，并对该地址写入值。鉴于这两种情况，因此需要将存取操作分别划分为两个阶段，首先取变量的地址，如果是左值则结束，右值则再对地址取值。

函数调用时，需要创建栈帧，
**********/

指令大致分为六类，分别是存取数指令、跳转指令、函数调用指令、算术运算指令和内建函数指令。存取数指令即对变量或常量数据进行存取操作的指令。跳转指令则控制程序的跳转。函数调用指令实现函数调用时参数及局部变量的存放、栈帧的创建，以及函数退出时调用现场的恢复。栈操作指令只有包含push指令，即将操作数放入栈顶。算术运算指令用以执行各种运算，如四则运算、取反、位移等。内建函数指令则是为了提供C语言部分库函数的功能而提供的指令，如I_PRTF指令调用C语言库函数printf，I_MALC指令调用C语言库函数malloc等。

存取数指令包括I_IMM、I_LEA、I_LI、I_LC、I_SI、I_SC、I_PUSH。

I_IMM指令用于获取立即数，带有一个参数指明该立即数。语句int a = 1;其中的1就是立即数，在编译时1将被识别为一个表达式，并生成代码I_IMM 1。
I_LEA指令用于获取局部变量，带有一个参数指明局部变量相对于bp寄存器的位置。进入函数内部后，函数的局部变量是相对于bp寄存器存储的，若要取相对于bp+4位置的变量，则需要指令I_LEA 4 来实现。
I_LI指令用于获取一个int类型的数据，不带参数。其将ax寄存器中的值看做该int类型数据的地址，并从中获取数据存入ax寄存器中。I_LC指令则是用于获取char类型的数据，操作方式和I_LI类似。
I_SI指令用于将一个int型数据存储到指定位置。待存储的值在ax寄存器中，存储的位置在栈顶，即将ax寄存器中的int值存储在栈顶所指的内存中。I_SC则是存储一个char型值。
I_PUSH指令用于将ax寄存器中的值放入栈顶中。

//TODO: 附带LI/SI/SI/SC指令功能示意图

跳转指令包括I_JMP、I_JZ、I_JNZ。

I_JMP指令用于无条件跳转，带有一个参数指明跳转的位置，实现直接跳转到某条指令的操作。
I_JZ指令用于条件跳转，带有一个参数指明跳转位置，当ax寄存器的值为0时，进行跳转。
I_JNZ指令则与I_JZ相反，用于当ax寄存器的值为非0时进行跳转。

函数调用指令包括I_CALL、I_ENT、I_LEV、I_ADJ。函数调用也是进行程序执行流程的跳转，但是I_JMP无法保存函数调用前的信息，因此需要重新设计一个指令用以创建调用帧并且跳转地址。在
函数调用结束后，也需要将参数出栈，并回复调用之前的现场。

I_CALL指令用于创建函数调用帧，并且实现程序执行流程跳转，带有一个参数指明函数的首指令。创建函数调用帧时，需要先存储函数返回后需要执行的指令地址，即pc+1所指的指令，然后是存储
bp寄存器和sp寄存器，因为这两个寄存器的当前值记录了调用函数前的信息。

I_ENT指令用于将函数的局部变量入栈，带有一个参数用于指明函数的局部变量个数。因为局部变量存放于栈上，因此在进入函数后，执行函数指令之前，需要为函数的局部变量预留栈空间。在函数
内部使用局部变量时，也是根据bp寄存器的位置来进行索引的。

I_LEV指令用于函数调用结束后恢复调用现场，不带参数。函数调用结束后，需要恢复sp寄存器、bp寄存器以及pc寄存器的值。

I_ADJ指令用于函数调用结束后将移除栈上的函数参数，不带参数。函数调用前，需要先将函数的参数入栈，然后再调用函数，因此在函数调用结束后，也需要将函数参数出栈，才能完全恢复函数调用前的现场。

//TODO: 附带函数调用时的帧栈结构图

```
运算符指令包括I_OR、I_XOR、I_AND、I_EQ、I_NE、I_LT、I_GT、I_LE、I_GE、I_SHL、I_SHR、I_ADD、I_SUB、I_MUL、I_DIV、I_MOD。这些指令都不带参数，其第一个操作数在栈顶，第二个操作数在ax寄存器中，计算时栈顶元素出栈，与ax寄存器中的值计算，计算结果存放于ax寄存器中。假设第一个操作数为p1，第二个操作数为p2，则：
I_OR指令实现p1|p2操作，
I_XOR指令实现p1^p2操作，
I_AND指令实现p1&p2操作，
I_EQ指令实现p1==p2，
I_NE指令实现p1!=p2操作，
I_LT指令实现p1<p2操作，
I_GT指令实现p1>p2操作，
I_LE指令实现p1<=p2操作，
I_GE指令实现p1>=p2操作，
I_SHL指令实现p1<<p2操作，
I_SHR指令实现p1>>p2操作，
I_ADD指令实现p1+p2操作，
I_SUB指令实现p1-p2操作，
I_MUL指令实现p1*p2操作，
I_DIV指令实现p1/p2操作，
I_MOD指令实现p1%p2。
```

内建函数指令包括I_PRTF、I_MALC、I_EXIT、I_SCANF、I_GETC、I_PUTC。因为编译器不支持多文件支持，因此无法直接使用C语言的各种库函数，因此特地设计几个内建函数指令，用于提供对常用C语言库函数的支持。其不带参数，而调用的库函数的参数存放在栈上，调用结果存放于ax寄存器中。
