基于寄存器的虚拟机在编译器生成代码阶段需要考虑寄存器分配的问题，并且指令集也更加复杂，因此虚拟机的实现也更加复杂，而基于栈的虚拟机则省去了这些不必要的麻烦，因此虚拟机设计部分采用基于栈的虚拟机。
基于栈的虚拟机指令，通常都是无地址指令，指令的操作数都隐含在栈上。部分指令可设计为带有操作数，可减少指令数量，且不会增加实现复杂度。
本指令集有带一个参数的指令和不带参数的指令。带一个参数的指令，其参数放在当前指令存储位置的下一个位置中。

指令大致分为六类，分别是存取数指令、跳转指令、函数调用指令、算术运算指令和内建函数指令。存取数指令即对变量或常量数据进行存取操作的指令。跳转指令则控制程序的跳转。函数调用指令实现函数调用时参数及局部变量的存放、栈帧的创建，以及函数退出时调用现场的恢复。算术运算指令用以执行各种运算，如四则运算、取反、位移等。内建函数指令则是为了提供C语言部分库函数的功能而提供的指令，如I_PRTF指令调用C语言库函数printf，I_MALC指令调用C语言库函数malloc等。

存取数指令包括I_IMM、I_LEA、I_LI、I_LC、I_SI、I_SC、I_PUSH，I_IMM用于取立即数，I_LEA用于取局部变量，I_LI和I_LC分别用于取int型数据的char型数据，I_SI和I_SC分别用于存储int型数据和char型数据，I_PUSH则将ax寄存器中的内容入栈。

跳转指令包括I_JMP、I_JZ、I_JNZ，分别完成无条件跳转、零跳转和非零跳转功能。

函数调用指令包括I_CALL、I_ENT、I_LEV、I_ADJ。函数调用也是进行程序执行流程的跳转，但是I_JMP无法保存函数调用前的信息，因此需要重新设计一个指令用以创建调用帧并且跳转地址。在
函数调用结束后，也需要将参数出栈，并回复调用之前的现场。因此这四条指令分别用来完成函数调用的各个阶段，I_CALL指令用于保存现场并调用函数，I_ENT指令用于在栈上预留局部变量的空间，I_LEV指令用于恢复调用现场，I_ADJ指令用于参数出栈。

//TODO: 附带函数调用时的帧栈结构图

```
运算符指令包括I_OR、I_XOR、I_AND、I_EQ、I_NE、I_LT、I_GT、I_LE、I_GE、I_SHL、I_SHR、I_ADD、I_SUB、I_MUL、I_DIV、I_MOD。这些指令都不带参数，其第一个操作数在栈顶，第二个操作数在ax寄存器中，计算时栈顶元素出栈，与ax寄存器中的值计算，计算结果存放于ax寄存器中。
内建函数指令包括I_PRTF、I_MALC、I_EXIT、I_SCANF、I_GETC、I_PUTC。因为编译器不支持多文件支持，因此无法直接使用C语言的各种库函数，因此特地设计几个内建函数指令，用于提供对常用C语言库函数的支持。其不带参数，而调用的库函数的参数存放在栈上，调用结果存放于ax寄存器中。
