
<!-- saved from url=(0048)http://lotabout.me/2016/write-a-C-interpreter-8/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>手把手教你构建 C 语言编译器（8）- 表达式 | 三点水</title><link rel="stylesheet" type="text/css" href="./手把手教你构建 C 语言编译器（8）- 表达式_files/normalize.css"><link rel="stylesheet" type="text/css" href="./手把手教你构建 C 语言编译器（8）- 表达式_files/highlight.css"><link rel="stylesheet" type="text/css" href="./手把手教你构建 C 语言编译器（8）- 表达式_files/font.css"><link rel="stylesheet" type="text/css" href="./手把手教你构建 C 语言编译器（8）- 表达式_files/noise.css"><link rel="stylesheet" type="text/css" href="./手把手教你构建 C 语言编译器（8）- 表达式_files/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="http://lotabout.me/favicon.ico"><link rel="alternate" type="application/atom+xml" href="http://lotabout.me/atom.xml"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="http://lotabout.me/">Home</a><a class="sidebar-nav-item" href="http://lotabout.me/archives">Archives</a><a class="sidebar-nav-item" href="http://lotabout.me/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="http://lotabout.me/tags/C/">C</a><a class="post-tag-link" href="http://lotabout.me/tags/compiler/">compiler</a></div><div class="post-time">2016-01-04</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（8）- 表达式</h1></div><div class="container post-content"><p>这是整个编译器的最后一部分，解析表达式。什么是表达式？表达式是将各种语言要素的一个组合，用来求值。例如：函数调用、变量赋值、运算符运算等等。</p>
<p>表达式的解析难点有二：一是运算符的优先级问题，二是如何将表达式编译成目标代码。我们就来逐一说明。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/" target="_blank" rel="noopener">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h1 id="运算符的优先级"><a href="http://lotabout.me/2016/write-a-C-interpreter-8/#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h1><p>运算符的优先级决定了表达式的运算顺序，如在普通的四则运算中，乘法 <code>*</code> 优先级高于加法 <code>+</code>，这就意味着表达式 <code>2 + 3 * 4</code> 的实际运行顺序是 <code>2 + (3 * 4)</code> 而不是
<code>(2 + 3) * 4</code>。</p>
<p>C 语言定义了各种表达式的优先级，可以参考 <a href="http://en.cppreference.com/w/c/language/operator_precedence" target="_blank" rel="noopener">C 语言运算符优先级</a>。</p>
<p>传统的编程书籍会用“逆波兰式”实现四则运算来讲解优先级问题。实际上，优先级关心的就是哪个运算符先计算，哪个运算符后计算（毕竟叫做“优先级”嘛）。而这就意味着我们需要决定先为哪个运算符生成目标代码（汇编），因为汇编代码是顺序排列的，我们必须先计算优先级高的运算符。</p>
<p>那么如何确定运算符的优先级呢？答曰：栈（递归调用的实质也是栈的处理）。</p>
<p>举一个例子：<code>2 + 3 - 4 * 5</code>，它的运算顺序是这样的：</p>
<ol>
<li>将 <code>2</code> 入栈</li>
<li>遇到运算符 <code>+</code>，入栈，此时我们期待的是<code>+</code>的另一个参数</li>
<li>遇到数字 <code>3</code>，原则上我们需要立即计算 <code>2+3</code>的值，但我们不确定数字 <code>3</code> 是否属于优先级更高的运算符，所以先将它入栈。</li>
<li>遇到运算符 <code>-</code>，它的优先级和 <code>+</code> 相同，此时判断参数 <code>3</code> 属于这前的 <code>+</code>。将运算符 <code>+</code> 出栈，并将之前的 <code>2</code> 和 <code>3</code> 出栈，计算 <code>2+3</code> 的结果，得到 <code>5</code> 入栈。同时将运算符 <code>-</code> 入栈。</li>
<li>遇到数字<code>4</code>，同样不能确定是否能立即计算，入栈</li>
<li>遇到运算符 <code>*</code> 优先级大于 <code>-</code>，入栈</li>
<li>遇到数字<code>5</code>，依旧不能确定是否立即计算，入栈</li>
<li>表达式结束，运算符出栈，为 <code>*</code>，将参数出栈，计算 <code>4*5</code> 得到结果 <code>20</code> 入栈。</li>
<li>运算符出栈，为 <code>-</code>，将参数出栈，计算 <code>5-20</code>，得到 <code>-15</code> 入栈。</li>
<li>此时运算符栈为空，因此得到结果 <code>-15</code>。</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// after step 1, 2</span><br><span class="line">|      |</span><br><span class="line">+------+</span><br><span class="line">| 3    |   |      |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 2    |   | +    |</span><br><span class="line">+------+   +------+</span><br><span class="line"></span><br><span class="line">// after step 4</span><br><span class="line">|      |   |      |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 5    |   | -    |</span><br><span class="line">+------+   +------+</span><br><span class="line"></span><br><span class="line">// after step 7</span><br><span class="line">|      |</span><br><span class="line">+------+</span><br><span class="line">| 5    |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 4    |   | *    |</span><br><span class="line">+------+   +------+</span><br><span class="line">| 5    |   | -    |</span><br><span class="line">+------+   +------+</span><br></pre></td></tr></tbody></table></figure>
<p>综上，在计算一个运算符‘x’之前，必须先查看它的右方，找出并计算所有优先级大于‘x’的运算符，之后再计算运算符‘x’。</p>
<p>最后注意的是优先通常只与多元运算符相关，单元运算符往往没有这个问题（因为只有一个参数）。也可以认为“优先级”的实质就是两个运算符在抢参数。</p>
<h1 id="一元运算符"><a href="http://lotabout.me/2016/write-a-C-interpreter-8/#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h1><p>上节中说到了运算符的优先级，也提到了优先级一般只与多元运算符有关，这也意味着一元运算符的优先级总是高于多元运算符。因为我们需要先对它们进行解析。</p>
<p>当然，这部分也将同时解析参数本身（如变量、数字、字符串等等）。</p>
<p>关于表达式的解析，与语法分析相关的部分就是上文所说的优先级问题了，而剩下的较难较烦的部分是与目标代码的生成有关的。因此对于需要讲解的运算符，我们主要从它的目标代码入手。</p>
<h2 id="常量"><a href="http://lotabout.me/2016/write-a-C-interpreter-8/#常量" class="headerlink" title="常量"></a>常量</h2><p>首先是数字，用 <code>IMM</code> 指令将它加载到 <code>AX</code> 中即可：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (token == Num) {</span><br><span class="line">    match(Num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// emit code</span></span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = token_val;</span><br><span class="line">    expr_type = INT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接着是字符串常量。它比较特殊的一点是 C 语言的字符串常量支持如下风格：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = <span class="string">"first line"</span></span><br><span class="line">    <span class="string">"second line"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>即跨行的字符串拼接，它相当于：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">p = <span class="string">"first linesecond line"</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>所以解析的时候要注意这一点：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'"'</span>) {</span><br><span class="line">    <span class="comment">// emit code</span></span><br><span class="line">    *++text = IMM;</span><br><span class="line">    *++text = token_val;</span><br><span class="line"></span><br><span class="line">    match(<span class="string">'"'</span>);</span><br><span class="line">    <span class="comment">// store the rest strings</span></span><br><span class="line">    <span class="keyword">while</span> (token == <span class="string">'"'</span>) {</span><br><span class="line">        match(<span class="string">'"'</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// append the end of string character '\0', all the data are default</span></span><br><span class="line">    <span class="comment">// to 0, so just move data one position forward.</span></span><br><span class="line">    data = (<span class="keyword">char</span> *)(((<span class="keyword">int</span>)data + <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &amp; (-<span class="keyword">sizeof</span>(<span class="keyword">int</span>)));</span><br><span class="line">    expr_type = PTR;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="sizeof"><a href="http://lotabout.me/2016/write-a-C-interpreter-8/#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p><code>sizeof</code> 是一个一元运算符，我们需要知道后面参数的类型，类型的解析在前面的文章中我们已经很熟悉了。</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (token == Sizeof) {</span><br><span class="line">    <span class="comment">// sizeof is actually an unary operator</span></span><br><span class="line">    <span class="comment">// now only `sizeof(int)`, `sizeof(char)` and `sizeof(*...)` are</span></span><br><span class="line">    <span class="comment">// supported.</span></span><br><span class="line">    match(Sizeof);</span><br><span class="line">    match(<span class="string">'('</span>);</span><br><span class="line">    expr_type = INT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token == Int) {</span><br><span class="line">        match(Int);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (token == Char) {</span><br><span class="line">        match(Char);</span><br><span class="line">        expr_type = CHAR;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    </span></pre></td></tr></tbody></table></figure></div></div></article></body></html>