```
一般函数的调用实现为：参数依序进栈后，call函数的地址，然后为局部变量预留栈空间。
示例代码:
void func(int a, int b, int c){
    int i, j;
    i=1;
    a=3;
    b=4;
    j=2;
    c=5;
}

int main(){
    func(1, 2, 3); //[1]
    return 0;
}

进入func后，栈结构为：
|   x   |
|   1   |  <-- a
|   2   |  <-- b
|   3   |  <-- c
|  pc+1 |  <-- 返回地址
|  bp   |  <-- bp
|  0    |  <-- 局部变量i
|  0    |  <-- 局部变量j  <-- sp

生成的代码为：
//第一个参数进栈
I_IMM   1
I_PUSH

//第二个参数进栈
I_IMM   2
I_PUSH

//第三个参数进栈
I_IMM   3
I_PUSH

//调用函数func
I_CALL  48631872

//为两个局部变量i和j预留两个空间
I_ENT   2

//对局部变量i赋值
I_LEA   -1
I_PUSH
I_IMM   1
I_SI

//对参数a赋值
I_LEA   4
I_PUSH
I_IMM   3
I_SI

//对参数b赋值
I_LEA   3
I_PUSH
I_IMM   4
I_SI

//对局部变量j赋值
I_LEA   -2
I_PUSH
I_IMM   2
I_SI

//对参数c赋值
I_LEA   2
I_PUSH
I_IMM   5
I_SI

//离开函数体
I_LEV

//函数参数出栈
I_ADJ   3
```

```
内置函数如printf的实现则不同，主要的工作就是将printf的参数准确地传入
C语言库本身的printf对应参数位置中。例如：

printf("a = %d\n", a);
主要工作是将字符串 "a = %d\n" 和 a 正确地传入C的库函数printf中。

示例代码：
int main(){
    int a; 
    int b;
    a=1;
    b=2;
    printf("a = %d, b = %d\n", a, b);
    return 0;
}

调用printf函数时的栈结构为：
|  ...       |
|  str_addr  |
|  a         |
|  b         |  <-- sp

生成的代码为：

//进入main函数，有两个局部变量
I_ENT   2

//对a赋值1
I_LEA   -1
I_PUSH
I_IMM   1
I_SI

//对b赋值2
I_LEA   -2
I_PUSH
I_IMM   2
I_SI

//将字符串 "a = %d, b = %d\n" 的首地址入栈
I_IMM   45989952
I_PUSH

//参数a入栈
I_LEA   -1
I_LI
I_PUSH

//参数b入栈
I_LEA   -2
I_LI
I_PUSH

//调用PRTF指令，其会调用C语言的库函数printf
I_PRTF

//printf函数的三个参数出栈
I_ADJ   3

//main函数返回
I_IMM   0
I_EXIT

执行I_PRTF指令的方式为：
if (inst == I_PRTF) {
    int* temp = sp + pc[1];
	ax = printf(reinterpret_cast<char*>(temp[-1]), temp[-2], temp[-3], temp[-4], temp[-5], temp[-6]);
}

当inst为I_PRTF时，pc为I_ADJ，pc[1]即pc+1为3，由退出函数时需要清除的参数个数，就可以
知道printf的第一个参数的前一个位置，此处就是sp+3，其中sp+2为str_addr，即第一个参数字符串的地址，
而sp+1则是a，sp则是b。因为在函数调用前就进行了参数个数及类型的比较，可避免printf取到过多的参数而越界。
因为只写到了temp[-6]，因此最多支持6个参数。
在I_PRTF执行后，还需I_ADJ 3来将参数出栈，完成内置函数printf的调用。
```
